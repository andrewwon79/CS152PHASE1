%{
#include <stdio.h>
int yyerror(char *s);
extern int yylex();  
%}




%start PROGRAM

%union{
   int int_value;
   float float_value;
   char* str_value;
}

%token FUNCTION BEGIN_PARAMS END_PARAMS BEGIN_LOCALS END_LOCALS BEGIN_BODY END_BODY INTEGER ARRAY OF IF THEN ENDIF ELSE WHILE DO FOR BEGINLOOP ENDLOOP CONTINUE READ WRITE AND OR NOT TRUE FALSE RETURN NEQ LT GT LTE GTE SUB ADD MULT DIV EQ L_PAREN R_PAREN MOD SEMICOLON COLON COMMA L_SQUARE_BRACKET R_SQUARE_BRACKET ASSIGN
%token<str_value> IDENTIFIER
%token<float_value> NUMBER

%left '-' '+' '*' '%' EQ NEQ '<' '>' LTE GTE ASSIGN 

%%

PROGRAM: %empty {printf("PROGRAM -> EPSILON\n");}
   | FUNCTIONRULE PROGRAM {printf("PROGRAM -> FUNCTIONRULE PROGRAM\n");}
   ;

FUNCTIONRULE: FUNCTION IDENTIFIERRULE ';' BEGIN_PARAMS FUNCTIONRECRULE END_PARAMS BEGIN_LOCALS FUNCTIONRECRULE END_LOCALS BEGIN_BODY FUNCTIONREC2RULE END_BODY {printf("FUNCTIONRULE -> FUNCTION IDENTIFIERRULE ; BEGIN_PARAMS FUNCTIONRECRULE END_PARAMS BEGIN_LOCALS FUNCTIONRECRULE END_LOCALS BEGIN_BODY FUNCTIONREC2RULE END_BODY\n");}
   ;

FUNCTIONRECRULE: %empty {printf("FUNCTIONRECRULE -> EPSILON\n");}
   | DECLARATION ';' FUNCTIONRECRULE {printf("FUNCTIONRECRULE -> DECLARATION ; FUNCTIONRECRULE\n");}
   ;

FUNCTIONREC2RULE: %empty {printf("FUNCTIONREC2RULE -> EPSILON\n");}
   | STATEMENT ';' FUNCTIONREC2RULE {printf("FUNCTIONREC2RULE -> STATEMENT ; FUNCTIONREC2RULE\n");}
   ;

DECLARATION: DECLARATIONREC ':' INTEGER {printf("DECLARATION -> DECLARATIONREC : INTEGER\n");}
   | DECLARATIONREC ':' ARRAY '[' NUMBER ']' OF INTEGER {printf("DECLARATION -> DECLARATIONREC : ARRAY [ NUMBER ] OF INTEGER\n");}
   | DECLARATIONREC ':' ARRAY '[' NUMBER ']' '[' NUMBER ']' OF INTEGER {printf("DECLARATION -> DECLARATIONREC : ARRAY [ NUMBER ] [ NUMBER ] OF INTEGER\n");}
   ;

DECLARATIONREC: %empty {printf("DECLARATIONREC -> EPSILON\n");}
   | IDENTIFIERRULE {printf("DECLARATIONREC -> IDENTIFIERRULE\n");}
   | DECLARATIONREC ',' IDENTIFIERRULE {printf("DECLARATIONREC -> DECLARATIONREC , IDENTIFIERRULE\n");}
   ;

STATEMENT: VAR ASSIGN EXPRESSION {printf("STATEMENT -> VAR := EXPRESSION\n");}
   | IF BOOLEXPRESSION THEN IFREC ENDIF {printf("STATEMENT -> IF BOOLEXPRESSION THEN IFREC ENDIF\n");}
   | IF BOOLEXPRESSION THEN IFREC ELSE IFREC ENDIF {printf("STATEMENT -> IF BOOLEXPRESSION THEN IFREC ELSE IFREC ENDIF\n");}
   | WHILE BOOLEXPRESSION BEGINLOOP WHILEREC ENDLOOP {printf("STATEMENT -> WHILE BOOLEXPRESSION BEGINLOOP WHILEREC ENDLOOP\n");}
   | DO BEGINLOOP DOREC ENDLOOP WHILE BOOLEXPRESSION {printf("STATEMENT -> DO BEGINLOOP DOREC ENDLOOP WHILE BOOLEXPRESSION\n");}
   | FOR VAR ASSIGN NUMBER ';' BOOLEXPRESSION ';' VAR ASSIGN EXPRESSION BEGINLOOP FORREC ENDLOOP {printf("statement -> FOR VAR := NUMBER ; BOOLEXPRESSION ; VAR := EXPRESSION BEGINLOOP FORREC ENDLOOP\n");}
   | READ READREC {printf("STATEMENT -> READ READREC\n");}
   | WRITE WRITEREC {printf("STATEMENT -> WRITE WRITEREC\n");}
   | VAR COMMA EXPRESSION {printf("STATEMENT -> VAR , EXPRESSION\n");}
   | VAR EXPRESSION {printf("STATEMENT -> VAR EXPRESSION\n");}
   | CONTINUE {printf("STATEMENT -> CONTINUE\n");}
   | RETURN EXPRESSION {printf("STATEMENT -> RETURN EXPRESSION\n");}
   ;

IFREC: %empty {printf("IFREC -> EPSILON\n");}
   | STATEMENT ';' IFREC {printf("IFREC -> STATEMENT ; IFREC\n");}
   ;

WHILEREC: %empty {printf("WHILEREC -> EPSILON\n");}
   | STATEMENT ';' WHILEREC {printf("WHILEREC -> STATEMENT ; WHILEREC\n");}
   ;

DOREC: %empty {printf("DOREC -> EPSILON\n");}
   | STATEMENT ';' DOREC {printf("DOREC -> STATEMENT ; DOREC\n");}
   ;

FORREC: %empty {printf("FORREC -> EPSILON\n");}
   | STATEMENT ';' FORREC {printf("FORREC -> STATEMENT ; FORREC\n");}
   ;

READREC: %empty {printf("READREC -> EPSILON\n");}
   | VAR {printf("READREC -> VAR\n");}
   | VAR ',' READREC {printf("READREC -> VAR , READREAC\n");}
   ;

WRITEREC: %empty {printf("WRITEREC -> EPSILON\n");}
   | VAR {printf("WRITEREC -> VAR\n");}
   | VAR ',' WRITEREC {printf("WRITEREC -> VAR , WRITEREC\n");}
   ;

BOOLEXPRESSION: RELATIONANDEXPRESSION {printf("BOOLEXPRESSION -> RELATIONANDEXPRESSION\n");}
   | RELATIONANDEXPRESSION BOOLEXPRESSIONREC {printf("BOOLEXPRESSION -> RELATIONANDEXPRESSION BOOLEXPRESSIONREC\n");}
   ;

BOOLEXPRESSIONREC: %empty {printf("BOOLEXPRESSIONREC -> EPSILON\n");}
   | BOOLEXPRESSIONREC OR RELATIONANDEXPRESSION {printf("BOOLEXPRESSIONREC -> BOOLEXPRESSIONREC OR RELATIONANDEXPRESSION\n");}
   ;

RELATIONANDEXPRESSION: RELATIONEXPRESSION {printf("RELATIONANDEXPRESSION -> RELATIONEXPRESSION\n");}
   | RELATIONEXPRESSION RELATIONANDEXPRESSIONREC {printf("RELATIONANDEXPRESSION -> RELATIONEXPRESSION RELATIONANDEXPRESSIONREC\n");}
   ;

RELATIONANDEXPRESSIONREC: %empty {printf("RELATIONANDEXPRESSIONREC -> EPSILON\n");}
   | RELATIONANDEXPRESSIONREC AND RELATIONEXPRESSION {printf("RELATIONANDEXPRESSIONREC -> RELATIONANDEXPRESSIONREC AND RELATIONEXPRESSION\n");}
   ;

RELATIONEXPRESSION: EXPRESSION COMPARATOR EXPRESSION {printf("RELATIONEXPRESSION -> EXPRESSION COMPARATOR EXPRESSION\n");}
   | TRUE {printf("RELATIONEXPRESSION -> TRUE\n");}
   | FALSE {printf("RELATIONEXPRESSION -> FALSE\n");}
   | '(' BOOLEXPRESSION ')' {printf("RELATIONEXPRESSION -> ( BOOLEXPRESSION )\n");}
   | NOT EXPRESSION COMPARATOR EXPRESSION {printf("RELATIONEXPRESSION -> NOT EXPRESSION COMPARATOR EXPRESSION\n");}
   | NOT TRUE {printf("RELATIONEXPRESSION -> NOT TRUE\n");}
   | NOT FALSE {printf("RELATIONEXPRESSION -> NOT FALSE\n");}
   | NOT '(' BOOLEXPRESSION ')' {printf("RELATIONEXPRESSION -> NOT ( BOOLEXPRESSION )\n");}

COMPARATOR: EQ {printf("COMPARATOR -> ==\n");}
   | NEQ {printf("COMPARATOR -> !=\n");}
   | '<' {printf("COMPARATOR -> <\n");}
   | '>' {printf("COMPARATOR -> >\n");}
   | LTE {printf("COMPARATOR -> <=\n");}
   | GTE {printf("COMPARATOR -> >=\n");}
   ;

EXPRESSION: MULTIPLICATIVEEXPRESSION {printf("EXPRESSION -> MULTIPLICATIVEEXPRESSION\n");}
   | MULTIPLICATIVEEXPRESSION EXPRESSIONREC {printf("EXPRESSION -> MULTIPLICATIVEEXPRESSION EXPRESSIONREC\n");}
   ;

EXPRESSIONREC: %empty {printf("EXPRESSIONREC -> EPSILON\n");}
   | EXPRESSIONREC '+' MULTIPLICATIVEEXPRESSION {printf("EXPRESSINOREC -> EXPRESSIONREC + MULTIPLICATIVEEXPRESSION\n");}
   | EXPRESSIONREC '-' MULTIPLICATIVEEXPRESSION {printf("EXPRESSIONREC -> EXPRESSIONREC - MULTIPLICATIVEEXPRESSION\n");}
   ;

MULTIPLICATIVEEXPRESSION: TERM {printf("MULTIPLICATIVEEXPRESSION -> TERM\n");}
   | TERM MULTIPLICATIVEEXPRESSIONTERM {printf("MULTIPLICATIVEEXPRESSION -> TERM MULTIPLICATIVEEXPRESSIONTERM\n");}
   ;

MULTIPLICATIVEEXPRESSIONTERM: %empty {printf("MULTIPLICATIVEEXPRESSIONTERM -> EPSILON\n");}
   | '*' TERM MULTIPLICATIVEEXPRESSIONTERM {printf("MULTIPLICATIVEEXPRESSIONTERM -> * TERM MULTIPLICATIVEEXPRESSIONTERM\n");}
   | '/' TERM MULTIPLICATIVEEXPRESSIONTERM {printf("MULTIPLICATIVEEXPRESSIONTERM -> / TERM MULTIPLICATIVEEXPRESSIONTERM\n");}
   | '%' TERM MULTIPLICATIVEEXPRESSIONTERM {printf("MULTIPLICATIVEEXPRESSIONTERM -> % TERM MULTIPLICATIVEEXPRESSIONTERM\n");}
   ;

TERM: IDENTIFIERRULE '(' TERMEXP ')' {printf("TERM -> IDENTIFIERRULE ( TERMEXP )\n");}
   | NUMBER {printf("TERM -> NUMBER\n");}
   | VAR {printf("TERM -> VAR\n");}
   | '(' EXPRESSION ')' {printf("TERM -> ( EXPRESSION )\n");}
   | '-' NUMBER {printf("TERM -> - NUMBER\n");}
   | '-' VAR {printf("TERM -> - VAR\n");}
   | '-' '(' EXPRESSION ')' {printf("TERM -> - ( EXPRESSION )\n");}
   ;


TERMEXP: %empty {printf("TERMEXP -> EPSILON\n");}
   | EXPRESSION {printf("TERMEXP -> EXPRESSION\n");}
   | EXPRESSION ',' TERMEXP {printf("TERMEXP -> EXPRESSION , TERMEXP\n");}
   ;

VAR: IDENTIFIERRULE {printf("VAR -> IDENTIFIERRULE\n");}
   | IDENTIFIERRULE '[' EXPRESSION ']' {printf("VAR -> IDENTIFIERRULE [ EXPRESSION ]\n");}
   | IDENTIFIERRULE '[' EXPRESSION ']' '[' EXPRESSION ']' {printf("VAR -> IDENTIFIERRULE [ EXPRESSION ] [ EXPRESSION ]\n");}
   ;


IDENTIFIERRULE: IDENTIFIER {printf("IDENTIFIERRULE -> IDENTIFIER %s\n",$1);}
   ;
%%


int main(int argc,char** argv)
{
   yyparse();
   return 0;
}

int yyerror(char *s)
{
   extern int currLine, currPos;
   extern char* yytext;
   printf("Bison error: %s, with symbol \"%s\", at line %d on column %d \n",s,yytext,currLine,currPos);
   return 0;
}
